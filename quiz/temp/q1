1.

Decidable => sorted-enumerable

Note that I denote by lexicographical order the order '<=', sorry for the inconvenience.

Consider the enumerator which works as follows:

Note: The first tape has a Turing machine that generates strings in lexicographical order (this can be done by generating all strings of each length in the lexicographical order in the usual sense and not the one in the first line of the proof, and then patching together all those for increasing lengths), and the second tape will run a decider D for this language on some input, and the third tape is the printing tape. (Note that we can make this work with two tapes instead of three, but for the sake of clarity, we use three tapes).

Now do the following:

For each string x in Sigma^* in lexicographical order {
    1. Copy x onto the second tape
    2. Run D on the string x
    3. If D accepts x, print x on the printing tape by copying from tape 1, else continue
}

Proof of correctness: For any string x, since D is a decider, it always halts, so we never get stuck on some string in x, and thus, all strings are considered. By construction, the output is always in sorted order. Noting that we print a string x iff D accepts it, we have that since L(D) = L, all strings in L are printed on the printing tape, and no other is, and since we print a string at most once, no string printed on the printing tape is printed more than once.

2.

If L is finite, then the statement is trivially true. Else we do the following.

We construct a 4-tape DTM that decides whether a string is in a sorted-enumerable language L or not as follows:

1. Tape 1 is meant to be the enumerator's work tape
2. Tape 2 is meant to be the enumerator's print tape
3. Tape 3 is meant to have the input as it is
4. Tape 4 is meant to be a tape that checks lexicographical <= between the contents of tape 2 and tape 3

We can construct a Turing machine that does the following:

For each string printed by the enumerator { // finding the location of the starting point of the last string can be done in one pass
    1. If this string has size < size of input, continue
    2. If this string has size > size of input, halt and reject
    3. If this string is = the input, halt and accept
}

Note that all the strings of length < |x| come before x in the enumeration of strings in L generated by the enumerator, and all strings of length > |x| come after x in the same enumeration.

Also note that the Turing machine described above skips all strings of length < |x| first (this is done in finite time due to a finite number of strings being < x), then checks whether there is a
string of length |x| in the language L which is equal to x (and this is done in finite time due to a similar reason as before), and if it isn't found (i.e., we go onto a string which has length >
|x|), then we reject (since x, if in the language, has to occur before all strings of length > |x|).

First we claim that this recognizes L, as follows:

1. Suppose string x is in L. Then L has at least one string of length |x|, and the above note implies that it is indeed found, so this DTM accepts x.
2. Suppose string x is in the language of this DTM. Then for some string in L, it must be equal to it (by the accepting condition), and hence we are done.

Now we show that this DTM is a decider.

For this, note that all the things inside the loop are done in a finite amount of time and all the number of iterations is upper bounded by (1 + the number of strings of lengths <= |x| in the language
L), which is finite, from where it follows that this DTM is a decider.


