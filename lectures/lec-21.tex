\documentclass[a4paper]{article}
\usepackage[english]{babel}
\usepackage[a4paper,top=2cm,bottom=2cm,left=2cm,right=2cm,marginparwidth=1.75cm]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
% \usepackage{amsthm}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{import}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{xcolor}
\usepackage{algorithmicx}
\usepackage{algpseudocode}

\usepackage{thmtools}
\usepackage{enumitem}
\usepackage[framemethod=TikZ]{mdframed}

\usepackage{xpatch}

\usepackage{boites}
\makeatletter
\xpatchcmd{\endmdframed}
{\aftergroup\endmdf@trivlist\color@endgroup}
{\endmdf@trivlist\color@endgroup\@doendpe}
{}{}
\makeatother

%\usepackage[poster]{tcolorbox}
%\allowdisplaybreaks
%\sloppy

\usepackage[many]{tcolorbox}

\xpatchcmd{\proof}{\itshape}{\bfseries\itshape}{}{}

% to set box separation
\setlength{\fboxsep}{0.8em}
\def\breakboxskip{7pt}
\def\breakboxparindent{0em}

\newenvironment{proof}{\begin{breakbox}\textit{Proof.}}{\hfill$\square$\end{breakbox}}
\newenvironment{ans}{\begin{breakbox}\textit{Answer.}}{\end{breakbox}}
\newenvironment{soln}{\begin{breakbox}\textit{Solution.}}{\end{breakbox}}

% \tcolorboxenvironment{proof}{
%     blanker,
%     before skip=\topsep,
%     after skip=\topsep,
%     borderline={0.4pt}{0.4pt}{black},
%     breakable,
%     left=12pt,
%     right=12pt,
%     top=12pt,
%     bottom=12pt,
% }
% 
% \tcolorboxenvironment{ans}{
%     blanker,
%     before skip=\topsep,
%     after skip=\topsep,
%     borderline={0.4pt}{0.4pt}{black},
%     breakable,
%     left=12pt,
%     right=12pt,
% }

\mdfdefinestyle{enclosed}{
    linecolor=black
    ,backgroundcolor=none
    ,apptotikzsetting={\tikzset{mdfbackground/.append style={fill=gray!100,fill opacity=.3}}}
    ,frametitlefont=\sffamily\bfseries\color{black}
    ,splittopskip=.5cm
    ,frametitlebelowskip=.0cm
    ,topline=true
    ,bottomline=true
    ,rightline=true
    ,leftline=true
    ,leftmargin=0.01cm
    ,linewidth=0.02cm
    ,skipabove=0.01cm
    ,innerbottommargin=0.1cm
    ,skipbelow=0.1cm
}

\mdfsetup{%
    middlelinecolor=black,
    middlelinewidth=1pt,
roundcorner=4pt}

\setlength{\parindent}{0pt}

\mdtheorem[style=enclosed]{theorem}{Theorem}
\mdtheorem[style=enclosed]{lemma}{Lemma}[theorem]
\mdtheorem[style=enclosed]{claim}{Claim}[theorem]
\mdtheorem[style=enclosed]{ques}{Question}
\mdtheorem[style=enclosed]{defn}{Definition}
\mdtheorem[style=enclosed]{notn}{Notation}
\mdtheorem[style=enclosed]{obs}{Observation}
\mdtheorem[style=enclosed]{eg}{Example}
\mdtheorem[style=enclosed]{cor}{Corollary}
\mdtheorem[style=enclosed]{note}{Note}

% \let\thetheorem=\relax
% \let\thelemma=\relax
% \let\theclaim=\relax
% \let\theques=\relax
% \let\thedefn=\relax
% \let\thenotn=\relax
% \let\theobs=\relax
% \let\thecor=\relax
% \let\thenote=\relax

% \renewcommand\qedsymbol{$\blacksquare$}
\newcommand{\nl}{\vspace{0.2cm}\\}
\newcommand{\mc}{\mathcal}
\newcommand{\mi}{\mathit}
\newcommand{\mf}{\mathbf}
\newcommand{\mb}{\mathbb}
\renewcommand{\L}{\mc{L}}
\newcommand{\hd}{\hat{\delta}}
\newcommand{\produces}{\implies}
\newcommand{\derives}{\stackrel{*}{\implies}}
\newcommand{\changesto}{\vdash}


\newcommand{\incfig}[1]{%
    \def\svgwidth{\columnwidth}
    \import{./figures/}{#1.pdf_tex}
}
\pdfsuppresswarningpagegroup=1

\title{\textbf{COL352 Lecture 21}}
\date{}

\begin{document}
\maketitle
\tableofcontents

\section{Recap}

Grammar $\implies$ PDA completed.\nl
More precisely, we showed in the last to last lecture that $L$ is recognized by a fast PDA $\iff$ $L$ is recognized by a PDA, and in the last lecture that $L$ is recognized by a fast PDA if $L$ is
generated by a grammar.

\section{Definitions}

\begin{defn}
    A (non-deterministic) pushdown automaton ((N)PDA) is a 6-tuple $(Q, \Sigma, \Gamma, \Delta, q_0, A)$ where
    \begin{enumerate}
        \item $Q$ -- finite nonempty set of states
        \item $\Sigma$ -- finite nonempty input alphabet
        \item $\Gamma$ -- finite stack alphabet
        \item $q_0 \in Q$ -- initial state
        \item $A$ -- set of accepting states
        \item $\Delta \subseteq Q \times \Sigma_\epsilon \times \Gamma_\epsilon \times Q \times \Gamma_\epsilon$, where $X_\epsilon$ is defined as $X \cup \{\epsilon\}$
    \end{enumerate}
\end{defn}

Note that in an NFA, $\Delta \subseteq Q \times (\Sigma \cup \{\epsilon\}) \times Q$.

\begin{defn}
    Let $P = (Q, \Sigma, \Gamma, \Delta, q_0, A)$ be a PDA. An instantaneous description (i.d.) of $P$ is a tuple $(q, x, \alpha)$ where $q \in Q$, $x \in \Sigma^*$, $\alpha \in \Gamma^*$. (The set
    of instantaneous descriptions is $Q \times \Sigma^* \times \Gamma^*$).
\end{defn}

\begin{defn}
    Let $P = (Q, \Sigma, \Gamma, \Delta, q_0, A)$ be a PDA. The relation $\changesto_P$ (read as ``changes to") is defined on the set of i.d.s as follows:\nl
    If $(q, a, B, q', B') \in \Delta$, then $(q, ax, B\alpha) \changesto_P (q', x, B'\alpha)$, and no other pairs of i.d.s are related.\nl
    In other words:
    \begin{align*}
        (q, y, \beta) \changesto_P (q', y', \beta') &\iff\\ &\exists a \in \Sigma_\epsilon, B \in \Gamma_\epsilon, \alpha \in \Gamma^*, B' \in \Gamma_\epsilon \text{ such that } y = ay', \beta =
    B\alpha, \beta' = B'\alpha, (q, a, B, q', B') \in \Delta
    \end{align*}
\end{defn}

\begin{defn}
    $\changesto^*_P$ is defined as the reflexive transitive closure of $\changesto$ (read as ``changes to in finitely many steps").
\end{defn}

\begin{defn}
    $x \in \Sigma^*$ is said to be accepted by PDA $P = (Q, \Sigma^*, \Gamma, \Delta, q_0, A)$ iff
    $$(q_0, x, \epsilon) \changesto^*_P (q, \epsilon, \alpha)$$
    for some $q \in A$ and some $\alpha \in \Gamma^*$.
\end{defn}

\begin{defn}
    The language recognized by PDA $P$ denoted by $\L(P)$ is $\{x \in \Sigma^* \mid P \text{ accepts }x\}$.
\end{defn}

\begin{defn}
We define a \underline{simple PDA} $P$ to be a PDA such that
\begin{enumerate}
    \item $\Delta = \Delta_{push} \uplus \Delta_{pop}$, where
        \begin{enumerate}
            \item $\Delta_{push}$ contains transitions $(q, a, \epsilon, q', B)$ where $q, q' \in Q, a \in \Sigma_\epsilon, B \in \Gamma$ (i.e., not allowed to pop, must push), and
            \item $\Delta_{pop}$ contains transitions $(q, a, B, q', \epsilon)$ where $q, q' \in Q, a \in \Sigma_\epsilon, B \in \Gamma$ (i.e., must pop, not allowed to push).
        \end{enumerate}
        \item $|A| = 1$, i.e., unique accepting state.
        \item If $x$ is accepted, then $x$ is accepted with an empty stack, i.e., $(q_{init}, x, \epsilon) \changesto^* (q_{acc}, \epsilon, \alpha)$ for some $\alpha \in \Sigma^*$ iff $q_{init},
            x, \epsilon) \changesto^* (q_{acc}, \epsilon, \epsilon)$.
\end{enumerate}
\end{defn}

\section{Content}

Now we need the following: If $L$ is recognized by a PDA, $L$ is generated by a grammar.\nl
We shall define something called a simple PDA, and show that it is as powerful as a PDA.\nl

Recall that PDA $P = (Q, \Sigma, \Gamma, \Delta, q_{init}, A)$ where $q_{init} \in Q, A \subseteq Q$, $\Delta \subseteq Q \times \Sigma_\epsilon \times \Gamma_\epsilon \times Q \times \Gamma_\epsilon$.

A simple PDA is defined as in the previous section.

\begin{claim}
    $L$ is recognized by a PDA iff $L$ is recognized by a simple PDA.
\end{claim}
\begin{proof}
    $\impliedby$ is trivial. We'll look at the other direction.\nl
    Suppose $L$ is recognized by PDA $P = (Q, \Sigma, \Gamma, \Delta, q_{init}, A)$.\nl
    To ensure condition 2, add a new state $q_{acc}$ to $Q$, make it the unique accepting state, and add transitions $(q, \epsilon, \epsilon, q_{acc}, \epsilon)$ for each $q \in A$.\nl
    To ensure condition 3, add transitions $(q_{acc}, \epsilon, B, q_{acc}, \epsilon)$ $\forall B \in \Gamma$.\nl
    To ensure condition 1, we need to break each transition that pushes as well as pops into two, i.e., replace the transition $(q, a, B, q', C)$ where $a \in \Sigma_\epsilon, B, C \in \Gamma$ by $(q,
    a, B, q'', \epsilon)$ and $(q'', \epsilon, C, q', \epsilon)$, and replace $(q, a, \epsilon, q', \epsilon)$ with $(q, a, \epsilon, q'', \$)$ and $(q'', \epsilon, \$, q', \epsilon)$.\nl
$P' = (Q \uplus \{q_{acc}\} \uplus \text{intermediate states}, \Sigma, \Gamma \uplus \{\$\}, q_{init}, \{q_{acc}\}\})$.
\end{proof}

Now our goal shall be the following.\nl
\begin{ques}
    Given simple PDA $P = (Q, \Sigma, \Gamma, \Delta, q_{init}, \{q_{acc}\})$, $\Delta = \Delta_{push} \uplus \Delta_{pop}$, construct a grammar $G = (N, \Sigma, R, S)$ such that\nl
    $$\forall x \in \Sigma^*: ((q_{init}, x, \epsilon) \changesto^* (q_{acc}, \epsilon, \epsilon) \iff  S \derives x)$$
\end{ques}

\begin{note}
    Idea: $N = \{V_{qq'} \mid (q, q') \in Q \times Q\}$. $R$ should ensure that $V_{qq'} \derives x \iff (q, x, \epsilon) \changesto^* (q', \epsilon, \epsilon)$ (i.e., $\exists$ a run of $P$ on $x$ starting from $q$ with empty stack and ending in $q'$
        with empty stack).\nl
        We also set $S$ to $v_{q_{init}q_{acc}}$.\nl
        The derivation should be something like $(q, x, \epsilon) \changesto \_ \changesto \_ \cdots \changesto \_ \changesto (q', \epsilon, \epsilon)$.\nl
        Is there an intermediate instantaneous description in which the stack is empty?
        If there is, then in the first part of the run, we have read off some prefix of $x$, and in the second part of the run, we have read off the remaining suffix of $x$, say $x = x_1 x_2$. We
        hope that $V_{qr} \derives x_1$ and $V_{rq'} \derives x_2$.\nl
        We want $V_{qq'} \derives x_1 x_2$, so we add the rule $V_{qq'} \to V_{qr} V_{rq'}$ to $R$, whihc will give us $V_{qq'} \produces V_{qr} V_{rq'} \derives x_1 x_2 = x$.\nl
        Now suppose the answer is no. Then the first transition must be a push transition and the last must be a pop transition, i.e., we go from $(q, x, \epsilon)$ to $(r, \_, B)$ where
        $(q, a, \epsilon, r, B) \in \Delta$ where $a = \epsilon$ or $x[1]$, and from $(r', \_, B')$ to $(q', \epsilon, \epsilon)$ where $(r', b, B', q
        , \epsilon)$ where $b = \epsilon$ or $x[n]$.
        Note that the stack has never been empty, so $B' = B$ (look at it from the perspective of the evolution of the stack over time).\nl
        So since $(q, x_1x_2, \epsilon) \changesto^* (r, x_1, \epsilon)$, and $x_1$ is not touched, we should have $(q, x_1, \epsilon) \changesto^* (r, \epsilon, \epsilon)$ maybe.
        In better terms, we have $(q, x, \epsilon) \changesto (r, x'b, B) \changesto \cdots \changesto (r', b, B) \changesto (q', \epsilon, \epsilon)$. $B$ is always in the stack for the
        intermediate places.\nl
        So we'll add $V_{qq'} \to aV_{rr'}b$ for $q, q', r, r' \in Q, a, b \in \Sigma_\epsilon$ if $\exists B \in \Gamma$ suh that $(q, a, \epsilon, r, B) \in \Delta_{push}$ and $(r', b, B, q',
        \epsilon) \in \Delta_{pop}$.
        Runs with 0 transitions: consume $\epsilon$, must start and end in the same state.
        So we'll add $V_{qq} \to \epsilon \forall q \in Q$.
\end{note}

\begin{theorem}
    Let $P = (Q, \Sigma, \Gamma, \Delta_{push} \uplus \Delta_{pop}, q_{init}, \{q_{acc}\})$ be a simple PDA. Let $G = (N, \Sigma, R_1 \cup R_2 \cup R_3, V_{q_{init}q_{pop}})$ be the grammar where
    \begin{enumerate}
        \item $N = \{V_{qq'} \mid (q, q') \in Q \times Q\}$
        \item $R_1 = \{V_{qq} \to \epsilon \mid q \in Q\}$, $R_2 = \{V_{qq'} \to V_{qr}V_{rq'} \mid (q, q', r) \in Q \times Q \times Q\}$, and $R_3 = \{V_{qq'} \to aV_{rr'}b \mid (q, q', r,r') \in
            Q\times Q \times Q \times Q, a, b \in \Sigma_\epsilon, \exists B \in \Gamma: (q, a, \epsilon, r, B) \in \Delta_{push}, (r', b, B, q', \epsilon) \in \Delta_{pop}\}$
    \end{enumerate}
    Then $\forall q, q' \in Q, x \in \Sigma^*$, $V_{qq'} \derives x$ iff $(q, x, \epsilon) \changesto^* (q', \epsilon, \epsilon)$.
\end{theorem}

\begin{proof}
    \begin{claim}
        $P, G$ as before, then $\forall q, q' \in Q, x \in \Sigma^*$, if $(q, x, \epsilon) \changesto^* (q', \epsilon, \epsilon)$, then $V_{qq'} \derives x$.
    \end{claim}
    \begin{proof}
        By induction on the number of transitions in a shortest run of $P$ from $(q, x, \epsilon)$ to $(q', \epsilon, \epsilon)$.\nl
        If the number of transitions is $0$, then $x = \epsilon$, so $q = q'$ and since $V_{qq} \to \epsilon \in R$, we have $V_{qq'} \derives x$.\nl
        If the number of transitions is more than 0.
        \begin{enumerate}
            \item $\exists$ an intermediate I.D. in the run having an empty stack. Let $r$ be the state in that I.D., suppose the run consumes $x_1$ before $r$ and $x_2$ after $r$.
                Then $x = x_1x_2, U = (r, x_2, \epsilon)$. Now break the run into two and show that it devolves into case 1 in the note (exercise).
            \item No intermediate I.D. has an empty stack, so $\exists B \in \Gamma, a, b \in \Gamma_\epsilon$ and states $r, r'$ such that $x = ax'b, (q, ax'b, \epsilon) \changesto (r, x;b, B)
                \changesto^* (r', b, B) \changesto (q', \epsilon, \epsilon)$, and the run from $(r, x'b, B)$ to $(r', b, B)$ doesn't pop the bottom-most $B$.\nl
                Since $(q, ax'b, \epsilon) \changesto (r, x'b, B), (q, a, \epsilon, r, B) \in Delta_{push}$.\nl
                Since $(r', b, B) \changesto (q', \epsilon, \epsilon), (r', b, B, q', \epsilon) \in \Delta_{pop}$.\nl
                Both of these together imply that $V_{qq} \to aV_{rr'}b \in R_3$.\nl
                Moreover, $(r, x', \epsilon) \changesto^* (r', \epsilon, \epsilon)$.
                By induction hypothesis, we have $V_{rr'} \derives x'$ since this run has 2 less transitions than the original run.
                So we have $V_{qq'} \produces aV_{rr'}b \derives x$.
        \end{enumerate}
    \end{proof}
    \begin{claim}
        $P, G$ as before, then $\forall q, q' \in Q, x \in \Sigma^*$, if $V_{qq'} \derives x$, then $(q, x, \epsilon) \changesto^* (q', \epsilon, \epsilon)$.
    \end{claim}
    \begin{proof}
        \todo[inline]{Continued from here}
        By induction on the number of productions in a shortest derivation of $x$ from$V_{qq'}$.\nl
        Base case: $\#$ productions = 1, so $x = \epsilon, q = q', (q, x, \epsilon) \changesto^* (q', \epsilon, \epsilon)$ is trivial because $\changesto^*$ is reflexive.\nl
        Inductive case: $\#$ productions $> 1$.
        \begin{enumerate}
            \item Case 1: 1st production applied is $V_{qq} \to V_{qr} V_{rq'}$ for some $r \in Q$. So $V_{qq'} \produces V_{qr}V_{rq'} \derives x$, so $\exists x_1, x_2$ such that $V_{qr} \derives
                x_2, V_{rq'} \derives x_2$ and $x = x_1x_2$. By the inductive hypothesis, we have $(q, x_1, \epsilon) \changesto^* (r, \epsilon, \epsilon)$ and $(r, x_2, \epsilon)
                \changesto^* (q', \epsilon, \epsilon)$. The first implies that $(q, x_1x_2, \epsilon) \changesto^* (r, x_2, \epsilon)$, and by transition closure property, we have $(q, x_1x_2,
                \epsilon) \changesto^* (q', \epsilon, \epsilon)$.
            \item Case 2: 1st production rule applied is $V_{qq'} \to aV_{rr'}b$ for some $r, r' \in Q$, $a, b \in \Sigma_{\epsilon}$. So $\exists x' : x = ax'b$ and $V_{rr'} \derives x'$. By
                induction hypothesis, since number of productions is less than the current number of productions, we have $(r, x', \epsilon) \changesto^* (r, \epsilon, \epsilon)$. So we have
                $(r, x'b, \epsilon) \changesto^* (r', b, \epsilon)$. Since this relation is in $R_3$, we have that $\exists B \in \Gamma$ such that $(q, a, \epsilon, r, B) \in \Delta_{push}) \in
                \Delta_{push}$ and $(r', b, B, q', \epsilon) \in \Delta_{pop}$. So we have $(q, x, \epsilon) = (q, ax'b, \epsilon) \changesto (r, x'b, B) \changesto^* (r', b, B) \changesto (q',
                \epsilon, \epsilon)$, so $(q, x, \epsilon) \changesto^* (q, \epsilon, \epsilon)$.
        \end{enumerate}
    \end{proof}
\end{proof}

\begin{cor}
    $\L(G) = \L(P)$
\end{cor}

\begin{proof}
    $V_{q_{init}q_{acc}} \derives x$ iff $(q_{init}, x, \epsilon) \changesto^* (q_{acc}, \epsilon, \epsilon)$.
\end{proof}

\begin{ques}
    How is the class of context free languages related to the class of regular languages?
\end{ques}

\begin{ans}
    The class of regular languages is $2^{\Sigma^*}$. Regular languages $\subset$ context free languages since every DFA can be simulated by some PDA (without using stack).
\end{ans}

Exercise: Given a DFA $D$, describe an easy construction of a grammar $G$ such that $\L(D) = \L(G)$.

\begin{ques}
    What kinds of closure properties can we think of for context free languages? Union? Intersection? Complementation? Concatenation? $*$?
\end{ques}

\begin{ans}
    Let $G = (N, \Sigma, R, S)$.

    For $*$: $G' = (N \uplus \{T\}, \Sigma, R \cup \{T \to TT, T \to S, T \to \epsilon\})$ generates $L^*$.

    Let $G = (N, \Sigma, R, S)$.
    
    For $\cup: G_1 = (N_1, \Sigma, R_1, S_1)$ generates $L_1$ and $G_2 = (N_2, \Sigma, R_2, S_2)$ generates $L_2$, then
    $(N_1 \uplus N_2 \uplus T, \Sigma, R_1 \cup R_2 \cup \{T \to S_1, T \to S_2\}, T)$ generates $L_1 \cup L_2$.\nl
    $(N_1 \uplus N_2 \uplus T, \Sigma, R_1 \cup R_2 \cup \{T \to S_1 S_2\}, T)$ generates $L_1 L_2$.\nl

    Not closed under intersection (would imply complementation by contradiction and contrapositive).\nl

    Let $L_1 = \{a^nb^nc^* \mid n \in \mb{N} \cup \{0\}\}$, and $L_2 = \{a^*b^nc^n \mid n \in \mb{N} \cup \{0\}\}$. Then $L_1 \cap L_2 = \{a^nb^nc^n \mid n \in \mb{N} \cup \{0\}\}$, which is
    probably not context free. We'll use a version of the pumping lemma for the DFA.
\end{ans}

\begin{note}
    Suppose $L$ is a context free language generated by a grammar $G$. Suppose $w \in L$ is a ``long enough" string. Consider a smallest parse tree $T$ of $w$. Since $w$ is ``long enough", $T$ is ``tall
    enough". Look at the longest root-to-leaf path in $T$, say $p$.\nl
    Since $p$ is long enough, some two nodes on $P$ are labelled by the same non-terminal, say $A \in N$. Let $uw'z$ be $w$ such that the upper $A$ derives $w'$, and let $vxy$ be $w'$. Look at tree
    (very helpful). Break it into $S, A$'s tree (having $u, z$), $A, A$'s tree (having $v, y$) and $A$'s tree (having $x$).\nl
    By copy pasting the second tree into itself again and again, we can get $\forall i : uv^ixy^iz \in L$. This doesn't give us anything if $y = v = \epsilon$, so we enforce smallest tree
    constraints.
\end{note}

\end{document}
