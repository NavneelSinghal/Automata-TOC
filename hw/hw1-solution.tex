\documentclass[a4paper]{article}
\usepackage[english]{babel}
\usepackage[a4paper,top=2cm,bottom=2cm,left=2cm,right=2cm,marginparwidth=1.75cm]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{import}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{xcolor}
\usepackage{algorithmicx}
\usepackage{algpseudocode}

\usepackage{thmtools}
\usepackage{enumitem}
\usepackage[framemethod=TikZ]{mdframed}

\usepackage{xpatch}

\makeatletter
\xpatchcmd{\endmdframed}
{\aftergroup\endmdf@trivlist\color@endgroup}
{\endmdf@trivlist\color@endgroup\@doendpe}
{}{}
\makeatother

%\usepackage[poster]{tcolorbox}
%\allowdisplaybreaks
%\sloppy

\usepackage[many]{tcolorbox}

\xpatchcmd{\proof}{\itshape}{\bfseries\itshape}{}{}

\newenvironment{ans} { 
    \vspace{12pt}
    \begin{mdframed}[skipabove=0pt,skipbelow=0pt,innertopmargin=0pt,innerbottommargin=0pt,leftline=false,bottomline=false,topline=false,rightline=false]%
    \noindent \textit{Answer.}  
}{%
    \end{mdframed}
    \vspace{12pt}
}

\tcolorboxenvironment{proof}{
    blanker,
    before skip=\topsep,
    after skip=\topsep,
    borderline={0.4pt}{0.4pt}{black},
    breakable,
    left=12pt,
    right=12pt,
    top=12pt,
    bottom=12pt,
}

\tcolorboxenvironment{ans}{
    blanker,
    before skip=\topsep,
    after skip=\topsep,
    borderline={0.4pt}{0.4pt}{black},
    breakable,
    left=12pt,
    right=12pt,
}

\mdfdefinestyle{enclosed}{
    linecolor=black
    ,backgroundcolor=none
    ,apptotikzsetting={\tikzset{mdfbackground/.append style={fill=gray!100,fill opacity=.3}}}
    ,frametitlefont=\sffamily\bfseries\color{black}
    ,splittopskip=.5cm
    ,frametitlebelowskip=.0cm
    ,topline=true
    ,bottomline=true
    ,rightline=true
    ,leftline=true
    ,leftmargin=0.01cm
    ,linewidth=0.02cm
    ,skipabove=0.01cm
    ,innerbottommargin=0.1cm
    ,skipbelow=0.1cm
}

\mdfsetup{%
    middlelinecolor=black,
    middlelinewidth=1pt,
roundcorner=4pt}

\setlength{\parindent}{0pt}

\mdtheorem[style=enclosed]{theorem}{Theorem}
\mdtheorem[style=enclosed]{lemma}{Lemma}[theorem]
\mdtheorem[style=enclosed]{claim}{Claim}[theorem]
\mdtheorem[style=enclosed]{ques}{Question}
\mdtheorem[style=enclosed]{defn}{Definition}
\mdtheorem[style=enclosed]{notn}{Notation}
\mdtheorem[style=enclosed]{obs}{Observation}
\mdtheorem[style=enclosed]{eg}{Example}
\mdtheorem[style=enclosed]{cor}{Corollary}
\mdtheorem[style=enclosed]{note}{Note}

% \let\thetheorem=\relax
% \let\thelemma=\relax
% \let\theclaim=\relax
% \let\theques=\relax
% \let\thedefn=\relax
% \let\thenotn=\relax
% \let\theobs=\relax
% \let\thecor=\relax
% \let\thenote=\relax

\renewcommand\qedsymbol{$\blacksquare$}
\newcommand{\nl}{\vspace{0.2cm}\\}
\newcommand{\mc}{\mathcal}
\newcommand{\mi}{\mathit}
\newcommand{\mf}{\mathbf}
\newcommand{\mb}{\mathbb}

\newcommand{\incfig}[1]{%
    \def\svgwidth{\columnwidth}
    \import{./figures/}{#1.pdf_tex}
}
\pdfsuppresswarningpagegroup=1

\title{\textbf{COL352 HW 1}}
\date{}

\begin{document}
\maketitle
\tableofcontents

\section{Problem 1}

Let $x, y, z \in \Sigma^*$ . We say that $z$ is a shuffle of $x$ and $y$ if the characters in $x$ and $y$ can be interleaved, while maintaining their relative order within $x$ and $y$, to get $z$.
Formally, if $|x| = m$ and $|y| = n$, then $|z|$ must be $m + n$, and it should be possible to partition the set $\{1, 2, \ldots, m + n\}$ into two increasing sequences, $i_1 < i_2 < \cdots < i_m$ and
$j_1 < j_2 < \cdots < j_n$, such that $z[i_k] = x[k]$ and $z[j_k] = y[k]$ for all $k$.\\

Given two languages $L_1, L_2 \subseteq \Sigma^*$, define $\mathrm{shuffle}(L_1, L_2) = \{z \in \Sigma^* \mid z \text{ is a shuffle of some } x \in L_1 \text{ and some } y \in L_2\}$.
Prove that the class of regular languages is closed under the shuffle operation.

\section{Problem 2}
Let $L_1$ be a regular language and $L_2$ be any language (not necessarily regular) over the same alphabet $\Sigma$.
Prove that the language $L = \{x \in \Sigma^* \mid x \cdot y \in L_1 \text{ for some } y \in L_2\}$ is regular. Do this by mathematically
defining a DFA for $L$ starting from a DFA for $L_1$ and the language $L_2$.

\section{Problem 3}
Prove that the class of regular languages is closed under inverse homomorphisms. That is, prove that if
$L \subseteq \Gamma^*$ is a regular language and $f : \Sigma^* \to \Gamma^*$ is a homomorphism, then $f^{-1}(L) = \{x \in \Sigma^* \mid f(x) \in L\}$
is regular. Do this by mathematically defining a DFA for $f^{-1}(L)$ starting from a DFA for $L$ and the
function $f$.

\section{Problem 4}
Prove that the class of regular languages is closed under homomorphisms. That is, prove that if $L \subseteq \Sigma^*$
is a regular language, then so is $f(L) = \{f(x) \mid x \in L\}$. Here, it is advisable to informally describe how
you will turn a DFA for $L$ into an NFA for $f(L)$.

\section{Problem 5}
Prove that if $L \subseteq \Sigma^*$ is a regular language then the language $L_0 = \{x \subseteq \Sigma^* \mid x \cdot rev(x) \in L\}$ is also
regular, where $rev(x)$ is the reverse of string x. Here, instead of constructing an NFA for $L_0$ directly, it
could be more convenient to use the already proven closure properties. For example, it might be better
to write $L_0$ as a union of a finite collection of languages, and then construct an NFA for each language
in that collection.

\begin{note}
    The motivation for the construction in the following proof comes from the fact that we want to run the DFA both forwards and backwards until both ``runs" end on the same state. This can be
    done if we reverse the second DFA and combine the states in a suitable manner using a cross product.
\end{note}

\begin{proof}

    Since $L$ is regular, there must be a DFA $D = (Q, \Sigma, \delta, q_0, A)$ that recognizes it. Consider the NFA $N = (Q, \Sigma, \Delta, A, \{q_0\})$, where $\Delta = \{(q', a, q) \mid \delta(q,
    a) = q', q \in Q, a \in A\}$, which recognizes $rev(L)$ as done in class.

    Now consider the NFA $N' = (Q \times Q, \Sigma, \Delta', \{q_0\} \times A, \{(q, q) \mid q \in Q\})$, where 

    $$\Delta' = \{((q, q'), a, (q'', q''')) \mid \delta(q, a) = q'' \land
    (q', a, q''') \in \Delta \land q, q', q'', q''' \in Q \land a \in \Sigma\}$$

    We shall show the following two claims, which shall complete the proof:\\

    \begin{claim}
        $\mc{L}(N') \subseteq L'$
    \end{claim}

    \begin{proof}
        Consider any string $x \in \mc{L}(N')$. Then we need to show that $x \cdot rev(x) \in L$. By the definition of $x$, there exists an accepting run of $x$ on $N'$. 


        ...
    \end{proof}

    \begin{claim}
        $L' \subseteq \mc{L}(N')$
    \end{claim}

    \begin{proof}
        Consider any string $x$ such that $x \cdot rev(x) \in L$. Then we need to construct an accepting run of $x$ on $N'$.

        ...
    \end{proof}

\end{proof}

\section{Problem 6}
Design an algorithm that takes as input the descriptions of two DFAs, $D_1$ and $D_2$, and determines
whether they recognize the same language.

\end{document}
