\documentclass[a4paper]{article}
\usepackage[english]{babel}
\usepackage[a4paper,top=2cm,bottom=2cm,left=2cm,right=2cm,marginparwidth=1.75cm]{geometry}
\usepackage{boites}
\usepackage{amsmath}
\usepackage{amsfonts}
% \usepackage{amsthm}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{import}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{xcolor}
\usepackage{algorithmicx}
\usepackage{algpseudocode}

\usepackage{thmtools}
\usepackage{enumitem}
\usepackage[framemethod=TikZ]{mdframed}

\usepackage{xpatch}

\makeatletter
\xpatchcmd{\endmdframed}
{\aftergroup\endmdf@trivlist\color@endgroup}
{\endmdf@trivlist\color@endgroup\@doendpe}
{}{}
\makeatother

%\usepackage[poster]{tcolorbox}
%\allowdisplaybreaks
%\sloppy

\usepackage[many]{tcolorbox}

%\xpatchcmd{\proof}{\itshape}{\bfseries\itshape}{}{}

\setlength{\parindent}{0pt}

\setlength{\fboxsep}{1em}
\def\breakboxskip{7pt}
\def\breakboxparindent{0em}

\newenvironment{proof}{\begin{breakbox}\textit{Proof.}}{\hfill$\square$\end{breakbox}}
\newenvironment{ans}{\begin{breakbox}\textit{Answer.}}{\end{breakbox}}
\newenvironment{soln}{\begin{breakbox}\textit{Solution.}}{\end{breakbox}}

% \tcolorboxenvironment{proof}{
%     blanker,
%     before skip=\topsep,
%     after skip=\topsep,
%     borderline={0.4pt}{0.4pt}{black},
%     enforce breakable,
%     left=12pt,
%     right=12pt,
%     top=12pt,
%     bottom=12pt,
% }
% 
% \tcolorboxenvironment{ans}{
%     blanker,
%     before skip=\topsep,
%     after skip=\topsep,
%     borderline={0.4pt}{0.4pt}{black},
%     enforce breakable,
%     left=12pt,
%     right=12pt,
%     top=12pt,
%     bottom=12pt,
% }

\mdfdefinestyle{enclosed}{
    linecolor=black
    ,backgroundcolor=none
    ,apptotikzsetting={\tikzset{mdfbackground/.append style={fill=gray!100,fill opacity=.3}}}
    ,frametitlefont=\sffamily\bfseries\color{black}
    ,splittopskip=.5cm
    ,frametitlebelowskip=.0cm
    ,topline=true
    ,bottomline=true
    ,rightline=true
    ,leftline=true
    ,leftmargin=0.01cm
    ,linewidth=0.02cm
    ,skipabove=0.01cm
    ,innerbottommargin=0.1cm
    ,skipbelow=0.1cm
}

\mdfdefinestyle{proofstyle}{
    linecolor=black
    ,backgroundcolor=none
    ,apptotikzsetting={\tikzset{mdfbackground/.append style={fill=gray!100,fill opacity=.3}}}
    ,frametitlefont=\sffamily\bfseries\color{black}
    ,splittopskip=.5cm
    ,frametitlebelowskip=.0cm
    ,topline=true
    ,bottomline=true
    ,rightline=true
    ,leftline=true
    ,leftmargin=0.01cm
    ,linewidth=0.02cm
    ,skipabove=0.01cm
    ,innerbottommargin=0.1cm
    ,skipbelow=0.1cm
    ,ntheorem=false
}

\mdfsetup{%
    middlelinecolor=black,
    middlelinewidth=1pt,
roundcorner=4pt}


\mdtheorem[style=enclosed]{theorem}{Theorem}
\mdtheorem[style=enclosed]{ques}{Question}
\mdtheorem[style=enclosed]{prob}{Problem}
\mdtheorem[style=enclosed]{lemma}{Lemma}[prob]
\mdtheorem[style=enclosed]{claim}{Claim}[prob]
\mdtheorem[style=enclosed]{defn}{Definition}
\mdtheorem[style=enclosed]{notn}{Notation}
\mdtheorem[style=enclosed]{obs}{Observation}
\mdtheorem[style=enclosed]{eg}{Example}
\mdtheorem[style=enclosed]{cor}{Corollary}
\mdtheorem[style=enclosed]{note}{Note}
%\mdtheorem[style=proofstyle]{proof}{Proof.}
% \mdtheorem[style=proofstyle]{ans}{Answer.}

% \let\theproof=\false
% \let\theans=\false
% \let\thetheorem=\relax
% \let\thelemma=\relax
% \let\theclaim=\relax
% \let\theques=\relax
% \let\thedefn=\relax
% \let\thenotn=\relax
% \let\theobs=\relax
% \let\thecor=\relax
\let\thenote=\relax

%\renewcommand\qedsymbol{$\blacksquare$}
\newcommand{\nl}{\vspace{0.2cm}\\}
\newcommand{\mc}{\mathcal}
\newcommand{\mi}{\mathit}
\newcommand{\mf}{\mathbf}
\newcommand{\mb}{\mathbb}
\renewcommand{\L}{\mc{L}}
\newcommand{\hd}{\hat{\delta}}

\newcommand{\incfig}[1]{%
    \def\svgwidth{\columnwidth}
    \import{./figures/}{#1.pdf_tex}
}
\pdfsuppresswarningpagegroup=1

\title{\textbf{COL352 HW 1}}
\date{}

\begin{document}
\maketitle

\begin{prob}
Let $x, y, z \in \Sigma^*$. We say that $z$ is a shuffle of $x$ and $y$ if the characters in $x$ and $y$ can be interleaved, while maintaining their relative order within $x$ and $y$, to get $z$.
Formally, if $|x| = m$ and $|y| = n$, then $|z|$ must be $m + n$, and it should be possible to partition the set $\{1, 2, \ldots, m + n\}$ into two increasing sequences, $i_1 < i_2 < \cdots < i_m$ and
$j_1 < j_2 < \cdots < j_n$, such that $z[i_k] = x[k]$ and $z[j_k] = y[k]$ for all $k$.\\

Given two languages $L_1, L_2 \subseteq \Sigma^*$, define $\mathrm{shuffle}(L_1, L_2) = \{z \in \Sigma^* \mid z \text{ is a shuffle of some } x \in L_1 \text{ and some } y \in L_2\}$.
Prove that the class of regular languages is closed under the shuffle operation.

\end{prob}


\input{1.tex}

\newpage

\begin{prob}
Let $L_1$ be a regular language and $L_2$ be any language (not necessarily regular) over the same alphabet $\Sigma$.
Prove that the language $L = \{x \in \Sigma^* \mid x \cdot y \in L_1 \text{ for some } y \in L_2\}$ is regular. Do this by mathematically
defining a DFA for $L$ starting from a DFA for $L_1$ and the language $L_2$.

\end{prob}

\input{2.tex}

\newpage

\begin{prob}
 Prove that the class of regular languages is closed under inverse homomorphisms. That is, prove that if
$L \subseteq \Gamma^*$ is a regular language and $f : \Sigma^* \to \Gamma^*$ is a homomorphism, then $f^{-1}(L) = \{x \in \Sigma^* \mid f(x) \in L\}$
is regular. Do this by mathematically defining a DFA for $f^{-1}(L)$ starting from a DFA for $L$ and the
function $f$.
\end{prob}

\input{3.tex}

\newpage
\begin{prob}
 Prove that the class of regular languages is closed under homomorphisms. That is, prove that if $L \subseteq \Sigma^*$
is a regular language, then so is $f(L) = \{f(x) \mid x \in L\}$. Here, it is advisable to informally describe how
you will turn a DFA for $L$ into an NFA for $f(L)$.
\end{prob}
\input{4.tex}

\newpage
\begin{prob}
 Prove that if $L \subseteq \Sigma^*$ is a regular language then the language $L_0 = \{x \subseteq \Sigma^* \mid x \cdot rev(x) \in L\}$ is also
regular, where $rev(x)$ is the reverse of string x. Here, instead of constructing an NFA for $L_0$ directly, it
could be more convenient to use the already proven closure properties. For example, it might be better
to write $L_0$ as a union of a finite collection of languages, and then construct an NFA for each language
in that collection.\\
\end{prob}
\input{5.tex}

\newpage
\begin{prob}
Design an algorithm that takes as input the descriptions of two DFAs, $D_1$ and $D_2$, and determines
whether they recognize the same language.
\end{prob}

\input{6.tex}

\end{document}
